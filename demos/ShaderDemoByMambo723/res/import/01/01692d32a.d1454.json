[{"__type__":"cc.EffectAsset","_name":"TurnPageEffect","properties":{"texture":{"type":13,"value":null},"alphaThreshold":{"value":0.5}},"techniques":[{"passes":[{"cullMode":0,"blend":true,"program":"9bdd0bf87fa890255650a604f496ff667c47e780db0c816c18d21094"}],"layer":0,"stages":["opaque"],"queue":0,"priority":0}],"shaders":[{"vert":"\n#define _IS_VERT_SHADER 1\n\nprecision highp float;\n\nuniform mat4 cc_matViewProj;\n\n#if _USE_MODEL\n  uniform mat4 cc_matWorld;\n#endif\n\nattribute vec3 a_position;\nattribute lowp vec4 a_color;\n\n#if USE_TEXTURE\n  attribute mediump vec2 a_uv0;\n  varying mediump vec2 v_uv0;\n#endif\n\nvarying lowp vec4 v_color;\n\nvoid main () {\n  mat4 mvp;\n  \n  #if _USE_MODEL\n    mvp = cc_matViewProj * cc_matWorld;\n  #else\n    mvp = cc_matViewProj;\n  #endif\n\n  #if USE_TEXTURE\n    v_uv0 = a_uv0;\n  #endif\n\n  v_color = a_color;\n\n  gl_Position = mvp * vec4(a_position, 1);\n}\n\n\n","frag":"\n#define _IS_FRAG_SHADER 1\n\nprecision highp float;\n\n#if USE_TEXTURE\n  uniform sampler2D texture;\n  varying mediump vec2 v_uv0;\n#endif\n\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\n\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\n\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\n\nvarying lowp vec4 v_color;\n\nuniform vec2 resolution;\nuniform vec2 mouse;\n\nconst float pi = 3.14159;\nconst float twopi = 6.28319;\n\nconst float e0 = 0.018;\nconst float ppow = 2.0;\n\nconst float bcolorMix = 0.67;\nconst float maxBcolVal = 0.4;\n\nconst float diffint = 1.2;\nconst float ambientt = 0.1;\nconst float ambientb = 0.4;\n\nconst vec2 specpos = vec2(0.85, -0.2);\nconst float specpow = 5.;\nconst float specwidth = 0.4;\nconst float specint = 0.6;\n\nconst vec2 shadowoffset = vec2(0.07, -0.04);\nconst float shadowsmoothness = 0.012;\nconst float shadowint = 0.25;\n\nconst float aawidth = 0.7;\nconst int aasamples = 3;\n\nconst bool showpoints = false;\nconst bool colors = false;\nconst bool anim = true;\n\nfloat random(float co)\n{\n  return fract(sin(co * 12.989) * 43758.545);\n}\n\nvec4 getPagebackColor()\n{\n  float cn = 1.;\n  vec4 pagebackColor;\n  pagebackColor.r = maxBcolVal * random(cn + 263.714);\n  pagebackColor.g = maxBcolVal * random(cn * 4. - 151.894);\n  pagebackColor.b = maxBcolVal * random(cn * 7. + 87.548);\n  pagebackColor.a = 1.0;\n  return pagebackColor;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n  float xr = vect.x * cos(angle) + vect.y * sin(angle);\n  float yr = vect.x * sin(angle) - vect.y * cos(angle);\n  return vec2(xr, yr);\n}\n\nfloat pageFunction(float x, float e)\n{\n  return pow(pow(x, ppow) - e, 1. / ppow);\n}\n\nfloat pageFunctionDer(float x, float e)\n{\n  return pow(x, ppow - 1.) / pow(pow(x, ppow) - e, (ppow - 1.) / ppow);\n}\n\nvec4 turnPage(vec2 fragCoord)\n{\n  \n  vec2 uv = v_uv0.xy; \n  float ratio = resolution.x / resolution.y;\n  \n  \n  vec2 mpoint;\n  bool firstcycle;\n  \n  \n  \n  vec2 Mouse2 = vec2(resolution.x / 2. + mouse.x, resolution.y / 2. - mouse.y);\n  #ifdef swap_x\n  Mouse2.x = resolution.x - Mouse2.x;\n  #endif\n  mpoint = Mouse2.xy;\n  firstcycle = true;\n  vec2 midmpoint = mpoint*0.5;\n  float mdist = distance(fragCoord, mpoint);\n  float e = e0*pow(mdist/resolution.y, 2.) + 0.02*e0*smoothstep(0., 0.12, mdist/resolution.y);\n  float angle = - atan(mpoint.x/mpoint.y) + pi*0.5;\n  \n  vec2 uv2 = uv;\n  #ifdef swap_x\n  uv2.x = ratio - uv2.x;\n  #endif\n  \n  vec2 uvr = rotateVec(uv2 - midmpoint/resolution.yy, angle);\n  \n  float pagefunc = pageFunction(uvr.x, e);\n  vec2 uvr2 = vec2(pagefunc, uvr.y); \n  vec2 uvr3 = rotateVec(uvr2, -angle) - vec2(1., -1.)*midmpoint/resolution.yy;\n  \n  vec2 uvr2b = vec2(-pagefunc, uvr.y); \n  vec2 uvr3b = rotateVec(uvr2b, -angle) - vec2(1., -1.)*midmpoint/resolution.yy;\n  \n  #ifdef swap_x\n  uvr3b.x = ratio - uvr3b.x;\n  #endif\n      \n  vec4 i; \n  \n  if (uvr.x > 0. && uvr3b.y > 0.) {\n    vec2 uvcorr = vec2(ratio, 1.);\n    vec2 uvrcorr = rotateVec(uvcorr - midmpoint / resolution.yy, angle);\n    float pagefunccorr = pageFunction(uvrcorr.x, e);\n    vec2 uvrcorr2 = vec2(-pagefunccorr, uvrcorr.y); \n    vec2 uvrcorr3 = rotateVec(uvrcorr2, -angle) - vec2(1., -1.) * midmpoint / resolution.yy;\n\n    float pagefuncder = pageFunctionDer(uvr.x, e);\n    float intfac = 1. - diffint*(1. - 1. / pagefuncder);\n\n    if(uvr3.x>=0. || uvr3.y<=0.) {\n      \n      float mdists = distance(fragCoord, mpoint)*0.7 - 55.;\n      float es = e0*pow(mdists/resolution.y, 2.) + 0.02*e0*smoothstep(0., 0.08, mdist/resolution.y);\n      vec2 uvrs = rotateVec(uv2 - midmpoint/resolution.yy - shadowoffset, angle);\n      float pagefuncs = pageFunction(uvrs.x + 0.015, es - 0.001);\n      vec2 uvr2s = vec2(pagefuncs, uvrs.y); \n      vec2 uvr3s = rotateVec(uvr2s, -angle) - vec2(1., -1.)*midmpoint/resolution.yy;\n      float shadow = 1. - (1. - smoothstep(-shadowsmoothness, shadowsmoothness, uvr3s.x))*(1. - smoothstep(shadowsmoothness, -shadowsmoothness, uvr3s.y));\n      \n      float difft = intfac*(1. - ambientt) + ambientt;\n      difft = difft*(shadow*shadowint + 1. - shadowint)/2. + mix(1. - shadowint, difft, shadow)/2.;\n      if (firstcycle)\n        i = difft*(colors?vec4(1., 0.3, 0.3, 1.):texture2D(texture, mod((uvr3b - uvrcorr3)/vec2(-ratio, 1.), 1.)));\n      else\n        i = difft*(colors?vec4(1., 0.3, 0.3, 1.):texture2D(texture, mod((uvr3b - uvrcorr3)/vec2(-ratio, 1.), 1.)));\n    }\n    else\n    {\n      \n      float diffb = intfac*(1. - ambientb) + ambientb;\n      float spec = pow(smoothstep(specpos.x - 0.35, specpos.x, intfac)*smoothstep(specpos.x + 0.35, specpos.x, intfac), specpow);\n      spec*= specint*pow(1. - pow(clamp(abs(uvr.y - specpos.y), 0., specwidth*2.), 2.)/specwidth, specpow);\n      if (firstcycle)\n        i = diffb*(colors?vec4(0.3, 1.0, 0.3, 1.):mix(texture2D(texture, mod((uvr3 - uvrcorr3)/vec2(-ratio, 1.), 1.)), getPagebackColor(), bcolorMix));\n      else\n        i = diffb*(colors?vec4(0.3, 1.0, 0.3, 1.):mix(texture2D(texture, mod((uvr3 - uvrcorr3)/vec2(-ratio, 1.), 1.)), getPagebackColor(), bcolorMix));\n      \n      i = mix(i, vec4(1.0), spec);\n    }\n  } else {\n    \n    vec2 mpointbg = vec2(0.2, 0.01);\n    vec2 midmpointbg = mpointbg*0.5;\n    float mdistbg = distance(fragCoord, mpointbg);\n    float ebg = e0*pow(mdistbg/resolution.y, 2.) + 0.01*e0*smoothstep(0., 0.12, mdistbg/resolution.y);\n    float anglebg = 0.001; \n    vec2 uvrbg = rotateVec(uv - midmpointbg/resolution.yy, anglebg);\n    \n    float pagefuncbg;\n    if (uvrbg.x<0.15)\n      pagefuncbg = uvrbg.x;\n    else\n      pagefuncbg = mix(uvrbg.x, pageFunction(uvrbg.x, ebg), smoothstep(mpoint.x/resolution.x + 0.1, mpoint.x/resolution.x, uvrbg.x));\n    \n    vec2 uvr2bbg = vec2(-pagefuncbg, uvrbg.y); \n    vec2 uvr3bbg = rotateVec(uvr2bbg, -anglebg) - vec2(1., -1.)*midmpointbg/resolution.yy;\n    vec2 uvcorrbg = vec2(ratio, 1.);\n    vec2 uvrcorrbg = rotateVec(uvcorrbg - midmpointbg/resolution.yy, anglebg);\n    float pagefunccorrbg = pageFunction(uvrcorrbg.x, ebg);\n    vec2 uvrcorr2bg = vec2(-pagefunccorrbg, uvrcorrbg.y); \n    vec2 uvrcorr3bg = rotateVec(uvrcorr2bg, -anglebg) - vec2(1., -1.)*midmpointbg/resolution.yy;       \n    float pagefuncderbg = pageFunctionDer(uvrbg.x, ebg);\n    float intfacbg = 1. - diffint*(1. - 1./pagefuncderbg);\n    float difftbg = intfacbg*(1. - ambientt) + ambientt;\n    \n    if (firstcycle) \n      i = colors?difftbg*vec4(0.3, 0.3, 1., 1.):texture2D(texture, mod((uvr3bbg - uvrcorr3bg)/vec2(-ratio, 1.), 1.));\n    else\n      i = colors?difftbg*vec4(0.3, 0.3, 1., 1.):texture2D(texture, mod((uvr3bbg - uvrcorr3bg)/vec2(-ratio, 1.), 1.));\n    float bgshadow = 1. + shadowint*smoothstep(-0.08+shadowsmoothness*4., -0.08, uvr3b.y) - shadowint;\n    \n    if (uvr3b.y<0.)\n    i*= bgshadow;\n  }\n  return i;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  \n  vec4 vs = vec4(0.);\n  for (int j = 0; j < aasamples; j++) {\n    float oy = float(j) * aawidth / max(float(aasamples - 1), 1.);\n    for (int i = 0; i < aasamples; i++) {\n      float ox = float(i) * aawidth / max(float(aasamples - 1), 1.);\n      vs += turnPage(fragCoord + vec2(ox, oy));\n    }\n  }\n  vec4 i = vs / vec4(aasamples * aasamples);\n  \n  \n  vec2 Mouse2 = vec2(resolution.x / 2. + mouse.x, resolution.y / 2. - mouse.y);\n  vec4 ocol; \n  if (showpoints) {\n    float ratio = resolution.x / resolution.y;\n    vec2 mpoint = Mouse2.xy;\n    vec2 midmpoint = Mouse2.xy * 0.5;\n    float mdist = distance(fragCoord, mpoint);\n    float midmdist = distance(fragCoord, midmpoint);\n    \n    ocol = mix(i, vec4(1., 0., 0., 1.), smoothstep(6., 4., mdist));\n    ocol = mix(ocol, vec4(1., 1., 0., 1.), smoothstep(6., 4., midmdist));\n  } else {\n    ocol = i;\n  }\n  fragColor = ocol;\n}\n\nvoid main () {\n  vec4 color = v_color;\n\n  #if USE_TEXTURE\n    color *= texture2D(texture, v_uv0);\n    mainImage(color, gl_FragCoord.xy);\n    #if _USE_ETC1_TEXTURE\n      color.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n    #endif\n  #endif\n\n  ALPHA_TEST(color);\n\n  gl_FragColor = color;\n}\n\n\n","defines":[{"name":"_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"swap_x","type":"boolean","defines":[]},{"name":"_USE_ETC1_TEXTURE","type":"boolean","defines":["USE_TEXTURE"]}],"uniforms":[{"name":"texture","type":13,"defines":["USE_TEXTURE"]},{"name":"alphaThreshold","type":4,"property":true,"defines":["USE_ALPHA_TEST"]},{"name":"resolution","type":5,"defines":[]},{"name":"mouse","type":5,"defines":[]}],"attributes":[{"name":"a_position","type":6,"defines":[]},{"name":"a_color","type":7,"defines":[]},{"name":"a_uv0","type":5,"defines":["USE_TEXTURE"]}],"extensions":[],"name":"9bdd0bf87fa890255650a604f496ff667c47e780db0c816c18d21094"}]},{"__type__":"cc.Material","_name":"TurnPageMaterial","_effectAsset":{"__uuid__":"a5BXShPQxHxLrvND3e2H3M"},"_defines":{"USE_TEXTURE":true},"_props":{}}]